// Whitespace and Comments
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT    = _{ "//" ~ (!NEWLINE ~ ANY)*  ~ NEWLINE}        // Single-line comments
BLOCK_COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" } // Block-style comments

// Tokens
IDENTIFIER =     @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
INTEGER         = @{ ASCII_DIGIT+ }
STRING_LITERAL  = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
BOOLEAN_LITERAL = { "true" | "false" }

// Operations
operation = _{ add | subtract | multiply | divide | power | and | or | lte | lt | gte | gt | eq | not_eq | not }
    add      = { "+" }
    subtract = { "-" }
    multiply = { "*" }
    divide   = { "/" }
    power    = { "^" }
    and      = { "&&" }
    or       = { "||" }
    lt       = { "<" }
    lte      = { "<=" }
    gt       = { ">" }
    gte      = { ">=" }
    eq       = { "==" }
    not_eq   = { "!=" }

// Types
size = { INTEGER }
base_type       = { "int" | "string" | "boolean" | IDENTIFIER }
array_dim       = { "[" ~ expression ~ "]" }
array_type      = { base_type ~ array_dim+ }
_type           = { array_type | base_type | "void" }
return_type     = { ":" ~ _type }
optional_return_type = _{ return_type? }

// Grammar Rules
empty             = _{ WHITESPACE* }
program           = { SOI ~ statement* ~ EOI }
statement         = { var_decl ~ ";" | func_decl | struct_decl | control_flow | io | sk_return | assignment ~ ";" | expression ~ ";" }
assignment        = { access  ~ "=" ~ expression }
empty_params      = { "(" ~WHITESPACE*~ ")" }
var_decl          = { IDENTIFIER ~ ":" ~ _type ~ "=" ~ expression }
func_decl         = { "function" ~ IDENTIFIER ~ ("(" ~ param_list ~ ")" | empty_params) ~ optional_return_type ~ "{" ~ statement* ~ "}" }
param_list        = { (IDENTIFIER ~ ":" ~ _type ~ ("," ~ IDENTIFIER ~ ":" ~ _type)*) }
struct_decl       = { "struct" ~ IDENTIFIER ~ "{" ~ struct_field_decl* ~ "}" }
struct_field_decl = { IDENTIFIER ~ ":" ~ _type ~ ";" }

// Struct Initialization
struct_init        = { IDENTIFIER ~ "{" ~ init_field_list? ~ "}" }
init_field_list    = { init_field ~ ("," ~ init_field)* }
init_field         = { IDENTIFIER ~ ":" ~ expression }

// Array Access and Initialization
array_access = { IDENTIFIER ~ array_dim+ }
array_init = { _type ~ "::new" ~ "(" ~ expression ~ ")" }

// Static function calls
static_func_call = { _type ~ "::" ~ IDENTIFIER ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }

// Control Flow
control_flow = {
    if_expr | for_expr | match_expr
}

if_expr = { "if" ~ "(" ~ expression ~ ")" ~ "{" ~ statement* ~ "}" ~ else_if_expr* ~ else_expr? }
else_if_expr = { "else" ~ "if" ~ "(" ~ expression ~ ")" ~ "{" ~ statement* ~ "}" }
else_expr = { "else" ~ "{" ~ statement* ~ "}" }

for_init     = { var_decl | assignment | empty }
for_cond     = { expression | empty }
for_update   = { assignment | empty }
for_expr     = { "for" ~ (for_in | for_classic | for_infinite) ~ "{" ~ statement* ~ "}" }
for_in       = { IDENTIFIER ~ "in" ~ expression }
for_classic  = { "(" ~ for_init ~ ";" ~ for_cond ~ ";" ~ for_update ~ ")" }
for_infinite = { "(" ~ expression? ~ ")" }
match_expr   = { "match" ~ "(" ~ expression ~ ")" ~ "{" ~ match_case* ~ "}" }

match_case      = { "case" ~ expression ~ ":" ~ "{" ~ statement* ~ "}" }

// I/O and Return
print           = { "print" ~ "(" ~ expression ~ ")" ~ ";" }
input           = { "input" ~ "(" ~ ")" ~ ";" }
io              = { print | input }

sk_return        = { "return" ~ expression ~ ";" }

// Expressions
expression      = { primary ~ (operation ~ primary)* }
not             = { "!" ~ primary }
primary         = { not | literal | static_func_call | func_call | struct_init | access | "(" ~ expression ~ ")" | IDENTIFIER }
literal         = { INTEGER | STRING_LITERAL | BOOLEAN_LITERAL }
func_call       = { IDENTIFIER ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }

// Member or array Access
// nested alternative to flat, experimental
// member_access =   { (array_access | func_call | IDENTIFIER)+  ~ ("." ~ access)+ }
// access = { member_access | array_access | IDENTIFIER }

// flat
access =   { (array_access | IDENTIFIER)  ~ ("." ~  (array_access | IDENTIFIER))* }

