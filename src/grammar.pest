// Whitespace and Comments
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT    = _{ "//" ~ (!NEWLINE ~ ANY)*  ~ NEWLINE}        // Single-line comments
BLOCK_COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" } // Block-style comments

// Tokens
IDENTIFIER =     @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
INTEGER         = @{ ASCII_DIGIT+ }
STRING_LITERAL  = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
BOOLEAN_LITERAL = { "true" | "false" }

KEYWORD         = { "if" | "else" | "for" | "match" | "function" | "return" }
PUNCTUATION     = { "{" | "}" | "(" | ")" | "[" | "]" | ";" | "," | ":" }

operation = _{ add | subtract | multiply | divide | power | and | or | lte | lt | gte| gt | eq | not_eq | not }
    add      = { "+" }
    subtract = { "-" }
    multiply = { "*" }
    divide   = { "/" }
    power    = { "^" }
    and      = { "&&" }
    or       = { "||" }
    lt       = { "<" }
    lte      = { "<=" }
    gt       = { ">" }
    gte      = { ">=" }
    eq       = { "==" }
    not_eq   = { "!=" }

// Types
size = { INTEGER }
base_type       = { "int" | "string" | "boolean" | IDENTIFIER }
array_dim       = { "[" ~ size ~ "]" }
array_type      = { base_type ~ array_dim+ }
_type           = { array_type | base_type | "void" }
return_type     = { ":" ~ _type }
optional_return_type = _{ return_type? }
// Grammar Rules
empty             = _{ WHITESPACE* }
program           = { SOI ~ statement* ~ EOI }
statement         = { var_decl ~";" | func_decl | struct_decl | control_flow | io | sk_return | assignment ~ ";" | expression ~ ";" }
assignment        = { member_access ~ "=" ~ expression }
empty_params      = { "(" ~WHITESPACE*~ ")" }
var_decl          = { IDENTIFIER ~ ":" ~ _type ~ "=" ~ expression }
func_decl         = { "function" ~ IDENTIFIER ~ ("(" ~ param_list ~ ")" | empty_params) ~ optional_return_type ~ "{" ~ statement* ~ "}" }
param_list        = { (IDENTIFIER ~ ":" ~ _type ~ ("," ~ IDENTIFIER ~ ":" ~ _type)*) }
struct_decl       = { "struct" ~ IDENTIFIER ~ "{" ~ struct_field_decl* ~ "}" }
struct_field_decl = { IDENTIFIER ~ ":" ~ _type ~ ";" }

// Struct Initialization
struct_init        = { IDENTIFIER ~ "{" ~ init_field_list? ~ "}" }
init_field_list    = { init_field ~ ("," ~ init_field)* }
init_field         = { IDENTIFIER ~ ":" ~ expression }

// Array initialization
// array_alloc = { base_type ~ ("[" ~ size ~ "]")+ }

// Static
static_func_call = { _type ~ "::" ~ IDENTIFIER ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }

control_flow = {
    if_expr | for_expr | match_expr
}

if_expr = { "if" ~ "(" ~ expression ~ ")" ~ "{" ~ statement* ~ "}" ~ else_if_expr* ~ else_expr? }
else_if_expr = { "else" ~ "if" ~ "(" ~ expression ~ ")" ~ "{" ~ statement* ~ "}" }
else_expr = { "else" ~ "{" ~ statement* ~ "}" }

for_init     = { var_decl | assignment | empty }
for_cond     = { expression | empty }
for_update   = { assignment | empty }
for_expr     = { "for" ~ (for_in | for_classic | for_infinite) ~ "{" ~ statement* ~ "}" }
for_in       = { IDENTIFIER ~ "in" ~ expression }
for_classic  = { "(" ~ for_init ~ ";" ~ for_cond ~ ";" ~ for_update ~ ")" }
for_infinite = { "(" ~ expression? ~ ")" }
match_expr   = { "match" ~ "(" ~ expression ~ ")" ~ "{" ~ match_case* ~ "}" }

match_case      = { "case" ~ expression ~ ":" ~ "{" ~ statement* ~ "}" }

print           = { "print" ~ "(" ~ expression ~ ")" ~ ";" }
input           = { "input" ~ "(" ~ ")" ~ ";" }
io              = { print | input }

sk_return        = { "return" ~ expression ~ ";" }
expression      = { primary ~ (operation ~ primary)* }
not             = { "!" ~ primary }
primary         = { not | literal | static_func_call |func_call | struct_init | member_access | "(" ~ expression ~ ")" | IDENTIFIER }
literal         = { INTEGER | STRING_LITERAL | BOOLEAN_LITERAL }
func_call       = { IDENTIFIER ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }

member_access   = { IDENTIFIER ~ ("." ~ IDENTIFIER)* }